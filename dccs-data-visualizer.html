<!-- 
  [æ–°æ‰‹æ•™å­¸] HTML æ–‡ä»¶çµæ§‹
  <!DOCTYPE html> å‘Šè¨´ç€è¦½å™¨é€™æ˜¯ä¸€å€‹æ¨™æº–çš„ HTML5 ç¶²é ã€‚
  <html> æ¨™ç±¤åŒ…è£¹äº†æ•´å€‹ç¶²é å…§å®¹ã€‚
-->
<!doctype html>
<html lang="zh-TW">
  <head>
    <!-- ===== åŸºæœ¬è¨­å®š ===== -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ===== ç¶²ç«™èº«åˆ†è­˜åˆ¥ ===== -->
    <meta
      name="description"
      content="DCCSèªçŸ¥å½ˆæ€§è¨“ç·´è³‡æ–™è¦–è¦ºåŒ–åˆ†æå·¥å…·ï¼Œå°ˆç‚ºç ”ç©¶äººå“¡è¨­è¨ˆçš„CSVè³‡æ–™åˆ†æå¹³å°"
    />
    <meta name="author" content="ä¸­åŸå¤§å­¸ç‰¹æ®Šæ•™è‚²å­¸ç³»ç¢©å£«ç­" />
    <meta
      name="keywords"
      content="DCCS, è³‡æ–™åˆ†æ, èªçŸ¥å½ˆæ€§, åŸ·è¡ŒåŠŸèƒ½, è¦–è¦ºåŒ–, CSV"
    />

    <!-- ===== å®‰å…¨æ€§è¨­å®š ===== -->
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob:; connect-src 'none';"
    />
    <meta http-equiv="X-Frame-Options" content="DENY" />
    <meta http-equiv="X-Content-Type-Options" content="nosniff" />

    <title>DCCS è³‡æ–™è¦–è¦ºåŒ–åˆ†æå·¥å…· | èªçŸ¥å½ˆæ€§è¨“ç·´æ•¸æ“šåˆ†æ</title>

    <!-- ===== Chart.js åœ–è¡¨åº« ===== -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <!-- ===== jsPDF - PDF ç”Ÿæˆåº«ï¼ˆåŒ…å«ä¸­æ–‡æ”¯æ´ï¼‰===== -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>

    <!-- ===== html2canvas - åœ–è¡¨è½‰åœ–ç‰‡ ===== -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- ===== Google Fonts - å­¸è¡“é¢¨æ ¼å­—é«” ===== -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=IBM+Plex+Sans:wght@300;400;500;600&display=swap"
      rel="stylesheet"
    />

    <style>
      /* =================================================================
           [æ–°æ‰‹æ•™å­¸] CSS è®Šæ•¸ (Variables)
           æˆ‘å€‘åœ¨ :root å®šç¾©é¡è‰²è®Šæ•¸ï¼Œä¹‹å¾Œåœ¨å…¶ä»–åœ°æ–¹ç”¨ var(--è®Šæ•¸å) ä¾†ä½¿ç”¨ã€‚
           é€™æ¨£å¦‚æœè¦æ”¹ä¸»é¡Œè‰²ï¼Œåªè¦æ”¹é€™è£¡çš„ä¸€å€‹è‰²ç¢¼ï¼Œå…¨ç«™éƒ½æœƒè®Šï¼
           è¨­è¨ˆç†å¿µï¼šå°ˆæ¥­ã€æ¸…æ™°ã€é©åˆé•·æ™‚é–“é–±è®€ (å­¸è¡“é¢¨æ ¼)
           ================================================================= */
      :root {
        /* ä¸»è‰²èª¿ - æ·±è—å­¸è¡“è‰² */
        --color-primary: #1e3a5f;
        --color-primary-light: #2d5a8f;
        --color-primary-dark: #0f1e3a;

        /* å¼·èª¿è‰² - æº«æš–æ©˜ç´… */
        --color-accent: #d97706;
        --color-accent-light: #fbbf24;

        /* ä¸­æ€§è‰² */
        --color-bg: #fafaf9;
        --color-surface: #ffffff;
        --color-border: #e5e7eb;
        --color-text: #1f2937;
        --color-text-light: #6b7280;

        /* ç‹€æ…‹è‰² */
        --color-success: #059669;
        --color-error: #dc2626;
        --color-warning: #d97706;

        /* å­—é«” */
        --font-display: "Crimson Pro", serif;
        --font-body: "IBM Plex Sans", sans-serif;

        /* é–“è· */
        --spacing-xs: 0.5rem;
        --spacing-sm: 1rem;
        --spacing-md: 1.5rem;
        --spacing-lg: 2rem;
        --spacing-xl: 3rem;

        /* åœ“è§’ */
        --radius-sm: 4px;
        --radius-md: 8px;
        --radius-lg: 12px;

        /* é™°å½± */
        --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07);
        --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
      }

      /* =================================================================
           å…¨åŸŸæ¨£å¼
           ================================================================= */
      /* 
         [æ–°æ‰‹æ•™å­¸] å…¨åŸŸæ¨£å¼é‡ç½®
         * ä»£è¡¨é¸å–æ‰€æœ‰å…ƒç´ ã€‚
         box-sizing: border-box; è®“ padding å’Œ border ä¸æœƒå¢åŠ å…ƒç´ çš„å¯¬åº¦ï¼Œé€™å°æ–¼æ’ç‰ˆéå¸¸é‡è¦ï¼
      */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: var(--font-body);
        background: linear-gradient(135deg, var(--color-bg) 0%, #f3f4f6 100%);
        color: var(--color-text);
        line-height: 1.6;
        min-height: 100vh;
        padding: var(--spacing-md);
      }

      /* =================================================================
           ä¸»å®¹å™¨
           ================================================================= */
      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      /* =================================================================
           é é¦–
           ================================================================= */
      header {
        background: var(--color-surface);
        border-left: 4px solid var(--color-accent);
        padding: var(--spacing-lg);
        margin-bottom: var(--spacing-xl);
        box-shadow: var(--shadow-md);
        border-radius: var(--radius-md);
      }

      h1 {
        font-family: var(--font-display);
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--color-primary);
        margin-bottom: var(--spacing-sm);
        letter-spacing: -0.02em;
      }

      .subtitle {
        font-size: 1.125rem;
        color: var(--color-text-light);
        font-weight: 300;
        letter-spacing: 0.01em;
      }

      /* =================================================================
           ä¸Šå‚³å€åŸŸ
           ================================================================= */
      .upload-section {
        background: var(--color-surface);
        padding: var(--spacing-xl);
        margin-bottom: var(--spacing-xl);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
        border: 2px dashed var(--color-border);
        transition: all 0.3s ease;
      }

      .upload-section:hover {
        border-color: var(--color-primary);
        box-shadow: var(--shadow-lg);
      }

      .upload-section h2 {
        font-family: var(--font-display);
        font-size: 1.75rem;
        color: var(--color-primary);
        margin-bottom: var(--spacing-md);
      }

      .file-input-wrapper {
        position: relative;
        display: inline-block;
        width: 100%;
        margin-bottom: var(--spacing-md);
      }

      .file-input-label {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-lg);
        background: linear-gradient(
          135deg,
          var(--color-primary) 0%,
          var(--color-primary-light) 100%
        );
        color: white;
        border-radius: var(--radius-md);
        cursor: pointer;
        font-weight: 500;
        transition: all 0.3s ease;
        box-shadow: var(--shadow-sm);
      }

      .file-input-label:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
      }

      .file-input-label:active {
        transform: translateY(0);
      }

      input[type="file"] {
        display: none;
      }

      .file-name {
        color: var(--color-text-light);
        font-size: 0.875rem;
        margin-top: var(--spacing-sm);
        text-align: center;
      }

      .instruction {
        background: #fef3c7;
        border-left: 4px solid var(--color-warning);
        padding: var(--spacing-md);
        margin-top: var(--spacing-md);
        border-radius: var(--radius-sm);
        font-size: 0.9rem;
        color: #92400e;
      }

      /* =================================================================
           åˆ†æçµæœå€åŸŸ
           ================================================================= */
      #analysisResults {
        display: none;
        animation: fadeIn 0.5s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* ç¸½è¦½å¡ç‰‡ */
      /* 
         [æ–°æ‰‹æ•™å­¸] Grid ç¶²æ ¼æ’ç‰ˆ
         display: grid; é–‹å•Ÿç¶²æ ¼æ¨¡å¼ã€‚
         grid-template-columns: repeat(auto-fit, minmax(...)); é€™æ˜¯ä¸€å€‹å¼·å¤§çš„ RWD æŠ€å·§ï¼Œè®“å¡ç‰‡è‡ªå‹•æ›è¡Œæ’åˆ—ï¼Œä¸ç”¨å¯« Media Queriesã€‚
      */
      .overview-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-xl);
      }

      .stat-card {
        background: var(--color-surface);
        padding: var(--spacing-lg);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
        border-top: 4px solid var(--color-accent);
        transition: all 0.3s ease;
      }

      .stat-card:hover {
        transform: translateY(-4px);
        box-shadow: var(--shadow-lg);
      }

      .stat-label {
        font-size: 0.875rem;
        color: var(--color-text-light);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: var(--spacing-xs);
        font-weight: 500;
      }

      .stat-value {
        font-family: var(--font-display);
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--color-primary);
        line-height: 1;
      }

      .stat-unit {
        font-size: 1rem;
        color: var(--color-text-light);
        font-weight: 400;
        margin-left: var(--spacing-xs);
      }

      /* åœ–è¡¨å®¹å™¨ */
      .charts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
        gap: var(--spacing-xl);
        margin-bottom: var(--spacing-xl);
      }

      .chart-container {
        background: var(--color-surface);
        padding: var(--spacing-xl);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
        border: 1px solid var(--color-border);
      }

      .chart-title {
        font-family: var(--font-display);
        font-size: 1.5rem;
        color: var(--color-primary);
        margin-bottom: var(--spacing-md);
        padding-bottom: var(--spacing-sm);
        border-bottom: 2px solid var(--color-border);
      }

      .chart-wrapper {
        position: relative;
        height: 350px;
        margin-top: var(--spacing-md);
      }

      /* è³‡æ–™è¡¨æ ¼ */
      .data-table-section {
        background: var(--color-surface);
        padding: var(--spacing-xl);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
        margin-bottom: var(--spacing-xl);
      }

      .table-container {
        overflow-x: auto;
        margin-top: var(--spacing-md);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
      }

      thead {
        background: var(--color-primary);
        color: white;
      }

      th {
        padding: var(--spacing-md);
        text-align: left;
        font-weight: 600;
        letter-spacing: 0.025em;
      }

      td {
        padding: var(--spacing-sm) var(--spacing-md);
        border-bottom: 1px solid var(--color-border);
      }

      tbody tr:hover {
        background: var(--color-bg);
      }

      /* åŒ¯å‡ºæŒ‰éˆ• */
      .export-section {
        background: var(--color-surface);
        padding: var(--spacing-xl);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
        text-align: center;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-md) var(--spacing-lg);
        background: var(--color-accent);
        color: white;
        border: none;
        border-radius: var(--radius-md);
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: var(--shadow-sm);
      }

      .btn:hover {
        background: var(--color-accent-light);
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }

      .btn:active {
        transform: translateY(0);
      }

      /* é å°¾ */
      footer {
        text-align: center;
        padding: var(--spacing-xl);
        color: var(--color-text-light);
        font-size: 0.875rem;
        margin-top: var(--spacing-xl);
      }

      /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
      /* 
         [æ–°æ‰‹æ•™å­¸] RWD éŸ¿æ‡‰å¼è¨­è¨ˆ (Media Queries)
         ç•¶è¢å¹•å¯¬åº¦å°æ–¼ 768px (å¹³æ¿/æ‰‹æ©Ÿ) æ™‚ï¼ŒåŸ·è¡Œé€™è£¡çš„ CSSã€‚
      */
      @media (max-width: 768px) {
        h1 {
          font-size: 2rem;
        }

        .charts-grid {
          grid-template-columns: 1fr;
        }

        .stat-value {
          font-size: 2rem;
        }
      }

      /* è¼‰å…¥å‹•ç•« */
      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top-color: white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- ===== é é¦– ===== -->
      <header>
        <h1>ğŸ“Š DCCS è³‡æ–™è¦–è¦ºåŒ–åˆ†æå·¥å…·</h1>
        <p class="subtitle">
          Dimensional Change Card Sort Â· èªçŸ¥å½ˆæ€§è¨“ç·´æ•¸æ“šåˆ†æå¹³å°
        </p>
      </header>

      <!-- ===== æª”æ¡ˆä¸Šå‚³å€ ===== -->
      <section class="upload-section">
        <h2>ğŸ“ ä¸Šå‚³ CSV æª”æ¡ˆ</h2>
        <div class="file-input-wrapper">
          <label for="csvFile" class="file-input-label">
            <span>ğŸ—‚ï¸</span>
            <span>é¸æ“‡ CSV æª”æ¡ˆ</span>
          </label>
          <input type="file" id="csvFile" accept=".csv" />
          <div class="file-name" id="fileName">å°šæœªé¸æ“‡æª”æ¡ˆ</div>
        </div>

        <div class="instruction">
          <strong>ğŸ“Œ ä½¿ç”¨èªªæ˜ï¼š</strong><br />
          è«‹ä¸Šå‚³å¾ DCCS è¨“ç·´éŠæˆ²åŒ¯å‡ºçš„ CSV æª”æ¡ˆã€‚æª”æ¡ˆæ‡‰åŒ…å«ä»¥ä¸‹æ¬„ä½ï¼š
          participant_id, phase, trial, rule, card_background, card_foreground,
          key_pressed, correct_key, is_correct, reaction_time_ms, timestamp
        </div>
      </section>

      <!-- ===== åˆ†æçµæœå€ ===== -->
      <div id="analysisResults">
        <!-- ç¸½è¦½çµ±è¨ˆå¡ç‰‡ -->
        <section class="overview-cards" id="overviewCards">
          <!-- å‹•æ…‹ç”Ÿæˆ -->
        </section>

        <!-- åœ–è¡¨å€åŸŸ -->
        <div class="charts-grid">
          <!-- éšæ®µåˆ¥æ­£ç¢ºç‡ -->
          <div class="chart-container">
            <h3 class="chart-title">éšæ®µåˆ¥æ­£ç¢ºç‡</h3>
            <div class="chart-wrapper">
              <canvas id="accuracyChart"></canvas>
            </div>
          </div>

          <!-- åæ‡‰æ™‚é–“è¶¨å‹¢ -->
          <div class="chart-container">
            <h3 class="chart-title">åæ‡‰æ™‚é–“è¶¨å‹¢</h3>
            <div class="chart-wrapper">
              <canvas id="reactionTimeChart"></canvas>
            </div>
          </div>

          <!-- è¦å‰‡é¡å‹è¡¨ç¾ -->
          <div class="chart-container">
            <h3 class="chart-title">è¦å‰‡é¡å‹è¡¨ç¾</h3>
            <div class="chart-wrapper">
              <canvas id="ruleTypeChart"></canvas>
            </div>
          </div>

          <!-- éŒ¯èª¤åˆ†å¸ƒ -->
          <div class="chart-container">
            <h3 class="chart-title">éŒ¯èª¤é¡å‹åˆ†å¸ƒ</h3>
            <div class="chart-wrapper">
              <canvas id="errorDistChart"></canvas>
            </div>
          </div>
        </div>

        <!-- è©³ç´°è³‡æ–™è¡¨ -->
        <section class="data-table-section">
          <h3 class="chart-title">ğŸ“‹ éšæ®µåˆ¥çµ±è¨ˆè©³æƒ…</h3>
          <div class="table-container">
            <table id="detailTable">
              <thead>
                <tr>
                  <th>éšæ®µ</th>
                  <th>è©¦é¡Œæ•¸</th>
                  <th>æ­£ç¢ºæ•¸</th>
                  <th>æ­£ç¢ºç‡</th>
                  <th>å¹³å‡åæ‡‰æ™‚é–“ (ms)</th>
                  <th>æœ€å¿«åæ‡‰ (ms)</th>
                  <th>æœ€æ…¢åæ‡‰ (ms)</th>
                </tr>
              </thead>
              <tbody id="detailTableBody">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
              </tbody>
            </table>
          </div>
        </section>

        <!-- åŒ¯å‡ºå ±å‘Š -->
        <section class="export-section">
          <h3 class="chart-title">ğŸ“¤ åŒ¯å‡ºåˆ†æå ±å‘Š</h3>
          <button class="btn" onclick="exportToPDF()" id="exportBtn">
            <span>ğŸ“„</span>
            <span>ä¸‹è¼‰å®Œæ•´ PDF å ±å‘Š</span>
          </button>
          <p
            style="
              margin-top: 1rem;
              color: var(--color-text-light);
              font-size: 0.875rem;
            "
          >
            å ±å‘Šå°‡åŒ…å«æ‰€æœ‰åœ–è¡¨ã€çµ±è¨ˆæ•¸æ“šèˆ‡è©³ç´°åˆ†æ
          </p>
        </section>
      </div>

      <!-- ===== é å°¾ ===== -->
      <footer>
        <p>Â© 2026 ä¸­åŸå¤§å­¸ç‰¹æ®Šæ•™è‚²å­¸ç³»ç¢©å£«ç­ | DCCS èªçŸ¥å½ˆæ€§è¨“ç·´ç ”ç©¶å°ˆæ¡ˆ</p>
        <p style="margin-top: 0.5rem">
          æœ¬å·¥å…·åƒ…ä¾›å­¸è¡“ç ”ç©¶ä½¿ç”¨ Â· æ‰€æœ‰è³‡æ–™è™•ç†å‡åœ¨ç€è¦½å™¨æœ¬åœ°å®Œæˆ
        </p>
      </footer>
    </div>

    <script>
      // =================================================================
      // [æ–°æ‰‹æ•™å­¸] JavaScript ç¨‹å¼é‚è¼¯å€
      // é€™è£¡è™•ç†æª”æ¡ˆè®€å–ã€è³‡æ–™åˆ†æã€åœ–è¡¨ç¹ªè£½èˆ‡ PDF åŒ¯å‡ºã€‚
      // =================================================================

      // å…¨åŸŸè®Šæ•¸ï¼šç”¨ä¾†å„²å­˜è®€å–é€²ä¾†çš„ CSV è³‡æ–™å’Œåœ–è¡¨ç‰©ä»¶
      let csvData = [];
      let charts = {};

      // =================================================================
      // [æ–°æ‰‹æ•™å­¸] äº‹ä»¶ç›£è½å™¨ (Event Listener)
      // ç•¶ä½¿ç”¨è€…é¸æ“‡æª”æ¡ˆæ™‚ ('change' äº‹ä»¶)ï¼Œè§¸ç™¼é€™å€‹å‡½å¼ã€‚
      // =================================================================
      document
        .getElementById("csvFile")
        .addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (file) {
            document.getElementById("fileName").textContent =
              `å·²é¸æ“‡ï¼š${file.name}`;
            readCSVFile(file);
          }
        });

      // =================================================================
      // [æ–°æ‰‹æ•™å­¸] FileReader API
      // é€™æ˜¯ç€è¦½å™¨å…§å»ºç”¨ä¾†è®€å–ä½¿ç”¨è€…é›»è…¦æª”æ¡ˆçš„å·¥å…·ã€‚
      // =================================================================
      function readCSVFile(file) {
        const reader = new FileReader();

        reader.onload = function (e) {
          const text = e.target.result;
          parseCSV(text);
        };

        reader.onerror = function () {
          alert("æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ï¼");
        };

        reader.readAsText(file);
      }

      // =================================================================
      // [æ–°æ‰‹æ•™å­¸] è³‡æ–™è§£æ (Parsing)
      // å°‡ç´”æ–‡å­—çš„ CSV è½‰æ›æˆ JavaScript å¯ä»¥æ“ä½œçš„ç‰©ä»¶é™£åˆ— (Array of Objects)ã€‚
      // =================================================================
      function parseCSV(text) {
        const lines = text.trim().split("\n");
        const headers = lines[0].split(",");

        csvData = [];

        for (let i = 1; i < lines.length; i++) {
          const values = lines[i].split(",");
          const row = {};

          headers.forEach((header, index) => {
            row[header.trim()] = values[index] ? values[index].trim() : "";
          });

          csvData.push(row);
        }

        console.log("âœ… CSV è³‡æ–™è¼‰å…¥å®Œæˆ:", csvData.length, "ç­†è¨˜éŒ„");
        analyzeData();
      }

      // =================================================================
      // è³‡æ–™åˆ†æä¸»å‡½æ•¸
      // =================================================================
      function analyzeData() {
        if (csvData.length === 0) {
          alert("æ²’æœ‰è³‡æ–™å¯ä¾›åˆ†æï¼");
          return;
        }

        // é¡¯ç¤ºåˆ†æçµæœå€åŸŸ
        document.getElementById("analysisResults").style.display = "block";

        // è¨ˆç®—çµ±è¨ˆæ•¸æ“š
        const stats = calculateStatistics();

        // ç”Ÿæˆç¸½è¦½å¡ç‰‡
        generateOverviewCards(stats);

        // ç”Ÿæˆåœ–è¡¨
        generateCharts(stats);

        // ç”Ÿæˆè©³ç´°è¡¨æ ¼
        generateDetailTable(stats);

        // æ»¾å‹•åˆ°çµæœå€åŸŸ
        document.getElementById("analysisResults").scrollIntoView({
          behavior: "smooth",
          block: "start",
        });
      }

      // =================================================================
      // è¨ˆç®—çµ±è¨ˆæ•¸æ“š
      // =================================================================
      function calculateStatistics() {
        // åŸºæœ¬çµ±è¨ˆ
        const totalTrials = csvData.length;
        const correctTrials = csvData.filter(
          (row) => row.is_correct === "TRUE",
        ).length;
        const accuracy = ((correctTrials / totalTrials) * 100).toFixed(1);

        // åæ‡‰æ™‚é–“çµ±è¨ˆ
        const reactionTimes = csvData.map((row) =>
          parseFloat(row.reaction_time_ms),
        );
        const avgReactionTime = (
          reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length
        ).toFixed(0);
        const minReactionTime = Math.min(...reactionTimes).toFixed(0);
        const maxReactionTime = Math.max(...reactionTimes).toFixed(0);

        // éšæ®µåˆ¥çµ±è¨ˆ
        const phaseStats = {};
        [1, 2, 3].forEach((phase) => {
          const phaseData = csvData.filter(
            (row) => parseInt(row.phase) === phase,
          );
          const phaseCorrect = phaseData.filter(
            (row) => row.is_correct === "TRUE",
          ).length;
          const phaseRT = phaseData.map((row) =>
            parseFloat(row.reaction_time_ms),
          );

          phaseStats[phase] = {
            total: phaseData.length,
            correct: phaseCorrect,
            accuracy: ((phaseCorrect / phaseData.length) * 100).toFixed(1),
            avgRT: (
              phaseRT.reduce((a, b) => a + b, 0) / phaseRT.length
            ).toFixed(0),
            minRT: Math.min(...phaseRT).toFixed(0),
            maxRT: Math.max(...phaseRT).toFixed(0),
          };
        });

        // è¦å‰‡é¡å‹çµ±è¨ˆ
        const ruleStats = {};
        ["color", "shape"].forEach((rule) => {
          const ruleData = csvData.filter((row) => row.rule === rule);
          const ruleCorrect = ruleData.filter(
            (row) => row.is_correct === "TRUE",
          ).length;

          ruleStats[rule] = {
            total: ruleData.length,
            correct: ruleCorrect,
            accuracy: ((ruleCorrect / ruleData.length) * 100).toFixed(1),
          };
        });

        // éŒ¯èª¤åˆ†å¸ƒ
        const errorsByPhase = {};
        [1, 2, 3].forEach((phase) => {
          const errors = csvData.filter(
            (row) =>
              parseInt(row.phase) === phase && row.is_correct === "FALSE",
          ).length;
          errorsByPhase[phase] = errors;
        });

        return {
          total: totalTrials,
          correct: correctTrials,
          accuracy: accuracy,
          avgRT: avgReactionTime,
          minRT: minReactionTime,
          maxRT: maxReactionTime,
          phases: phaseStats,
          rules: ruleStats,
          errors: errorsByPhase,
        };
      }

      // =================================================================
      // ç”Ÿæˆç¸½è¦½å¡ç‰‡
      // =================================================================
      function generateOverviewCards(stats) {
        const container = document.getElementById("overviewCards");

        const cards = [
          { label: "ç¸½è©¦é¡Œæ•¸", value: stats.total, unit: "é¡Œ" },
          { label: "æ•´é«”æ­£ç¢ºç‡", value: stats.accuracy, unit: "%" },
          { label: "å¹³å‡åæ‡‰æ™‚é–“", value: stats.avgRT, unit: "ms" },
          { label: "ç¸½éŒ¯èª¤æ•¸", value: stats.total - stats.correct, unit: "æ¬¡" },
        ];

        container.innerHTML = cards
          .map(
            (card) => `
                <div class="stat-card">
                    <div class="stat-label">${card.label}</div>
                    <div>
                        <span class="stat-value">${card.value}</span>
                        <span class="stat-unit">${card.unit}</span>
                    </div>
                </div>
            `,
          )
          .join("");
      }

      // =================================================================
      // ç”Ÿæˆåœ–è¡¨
      // =================================================================
      function generateCharts(stats) {
        // éŠ·æ¯€èˆŠåœ–è¡¨
        Object.values(charts).forEach((chart) => chart && chart.destroy());
        charts = {};

        // åœ–è¡¨é…è‰²
        const colors = {
          primary: "#1e3a5f",
          accent: "#d97706",
          success: "#059669",
          error: "#dc2626",
          phase1: "#3b82f6",
          phase2: "#8b5cf6",
          phase3: "#ec4899",
        };

        // 1. éšæ®µåˆ¥æ­£ç¢ºç‡
        const ctx1 = document.getElementById("accuracyChart").getContext("2d");
        charts.accuracy = new Chart(ctx1, {
          type: "bar",
          data: {
            labels: [
              "éšæ®µä¸€\n(é¡è‰²åˆ†é¡)",
              "éšæ®µäºŒ\n(å½¢ç‹€åˆ†é¡)",
              "éšæ®µä¸‰\n(æ··åˆè½‰æ›)",
            ],
            datasets: [
              {
                label: "æ­£ç¢ºç‡ (%)",
                data: [
                  stats.phases[1].accuracy,
                  stats.phases[2].accuracy,
                  stats.phases[3].accuracy,
                ],
                backgroundColor: [colors.phase1, colors.phase2, colors.phase3],
                borderWidth: 0,
                borderRadius: 8,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (context) => `æ­£ç¢ºç‡: ${context.parsed.y}%`,
                },
              },
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                ticks: {
                  callback: (value) => value + "%",
                },
              },
            },
          },
        });

        // 2. åæ‡‰æ™‚é–“è¶¨å‹¢
        const ctx2 = document
          .getElementById("reactionTimeChart")
          .getContext("2d");
        charts.reactionTime = new Chart(ctx2, {
          type: "line",
          data: {
            labels: ["éšæ®µä¸€", "éšæ®µäºŒ", "éšæ®µä¸‰"],
            datasets: [
              {
                label: "å¹³å‡åæ‡‰æ™‚é–“ (ms)",
                data: [
                  stats.phases[1].avgRT,
                  stats.phases[2].avgRT,
                  stats.phases[3].avgRT,
                ],
                borderColor: colors.accent,
                backgroundColor: "rgba(217, 119, 6, 0.1)",
                fill: true,
                tension: 0.4,
                borderWidth: 3,
                pointRadius: 6,
                pointBackgroundColor: colors.accent,
                pointBorderColor: "#fff",
                pointBorderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
            },
            scales: {
              y: {
                beginAtZero: false,
                ticks: {
                  callback: (value) => value + " ms",
                },
              },
            },
          },
        });

        // 3. è¦å‰‡é¡å‹è¡¨ç¾
        const ctx3 = document.getElementById("ruleTypeChart").getContext("2d");
        charts.ruleType = new Chart(ctx3, {
          type: "doughnut",
          data: {
            labels: ["é¡è‰²è¦å‰‡", "å½¢ç‹€è¦å‰‡"],
            datasets: [
              {
                data: [stats.rules.color.correct, stats.rules.shape.correct],
                backgroundColor: [colors.phase1, colors.phase3],
                borderWidth: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: "bottom",
              },
              tooltip: {
                callbacks: {
                  label: (context) => {
                    const label = context.label;
                    const value = context.parsed;
                    const total = context.dataset.data.reduce(
                      (a, b) => a + b,
                      0,
                    );
                    const percentage = ((value / total) * 100).toFixed(1);
                    return `${label}: ${value} é¡Œ (${percentage}%)`;
                  },
                },
              },
            },
          },
        });

        // 4. éŒ¯èª¤åˆ†å¸ƒ
        const ctx4 = document.getElementById("errorDistChart").getContext("2d");
        charts.errorDist = new Chart(ctx4, {
          type: "bar",
          data: {
            labels: ["éšæ®µä¸€", "éšæ®µäºŒ", "éšæ®µä¸‰"],
            datasets: [
              {
                label: "éŒ¯èª¤æ¬¡æ•¸",
                data: [stats.errors[1], stats.errors[2], stats.errors[3]],
                backgroundColor: colors.error,
                borderWidth: 0,
                borderRadius: 8,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                },
              },
            },
          },
        });
      }

      // =================================================================
      // ç”Ÿæˆè©³ç´°è¡¨æ ¼
      // =================================================================
      function generateDetailTable(stats) {
        const tbody = document.getElementById("detailTableBody");

        const rows = [1, 2, 3]
          .map((phase) => {
            const data = stats.phases[phase];
            return `
                    <tr>
                        <td><strong>éšæ®µ ${phase}</strong></td>
                        <td>${data.total}</td>
                        <td>${data.correct}</td>
                        <td><strong>${data.accuracy}%</strong></td>
                        <td>${data.avgRT}</td>
                        <td>${data.minRT}</td>
                        <td>${data.maxRT}</td>
                    </tr>
                `;
          })
          .join("");

        tbody.innerHTML = rows;
      }

      // =================================================================
      // SVG æ–‡å­—è½‰ PNG åœ–ç‰‡ï¼ˆæ”¯æ´ä¸­æ–‡ï¼‰
      // =================================================================
      function createChineseTextImage(
        text,
        fontSize = 100,
        fontWeight = "bold",
        color = "#1e3a5f",
      ) {
        return new Promise((resolve, reject) => {
          try {
            // å»ºç«‹ SVG å…ƒç´ 
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");

            // è¨­å®š SVG å°ºå¯¸ï¼ˆæ ¹æ“šæ–‡å­—é•·åº¦ï¼‰
            const width = text.length * fontSize * 0.9;
            const height = fontSize * 1.5;

            svg.setAttribute("width", width);
            svg.setAttribute("height", height);
            svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
            svg.setAttribute("xmlns", svgNS);

            // å»ºç«‹æ–‡å­—å…ƒç´ 
            const textElement = document.createElementNS(svgNS, "text");
            textElement.setAttribute("x", "50%");
            textElement.setAttribute("y", "50%");
            textElement.setAttribute("text-anchor", "middle");
            textElement.setAttribute("dominant-baseline", "central");
            textElement.setAttribute(
              "font-family",
              '"Microsoft JhengHei", "PingFang TC", "Noto Sans TC", "é»‘é«”-ç¹", "å¾®è»Ÿæ­£é»‘é«”", sans-serif',
            );
            textElement.setAttribute("font-size", fontSize);
            textElement.setAttribute("font-weight", fontWeight);
            textElement.setAttribute("fill", color);
            textElement.textContent = text;

            svg.appendChild(textElement);

            // å°‡ SVG è½‰æ›ç‚º Data URL
            const svgString = new XMLSerializer().serializeToString(svg);
            const svgBlob = new Blob([svgString], {
              type: "image/svg+xml;charset=utf-8",
            });
            const url = URL.createObjectURL(svgBlob);

            // å»ºç«‹åœ–ç‰‡å…ƒç´ 
            const img = new Image();
            img.onload = () => {
              // å»ºç«‹ Canvas
              const canvas = document.createElement("canvas");
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext("2d");

              // ç¹ªè£½åœ–ç‰‡åˆ° Canvas
              ctx.drawImage(img, 0, 0);

              // è½‰æ›ç‚º PNG Data URL
              const pngDataUrl = canvas.toDataURL("image/png", 1.0);

              // æ¸…ç†
              URL.revokeObjectURL(url);

              resolve({
                dataUrl: pngDataUrl,
                width: width,
                height: height,
              });
            };

            img.onerror = () => {
              URL.revokeObjectURL(url);
              reject(new Error("Failed to load SVG image"));
            };

            img.src = url;
          } catch (error) {
            reject(error);
          }
        });
      }

      // =================================================================
      // [æ–°æ‰‹æ•™å­¸] éåŒæ­¥å‡½å¼ (Async/Await)
      // å› ç‚ºç”Ÿæˆåœ–ç‰‡å’Œ PDF éœ€è¦æ™‚é–“ï¼Œæˆ‘å€‘ä½¿ç”¨ async/await é—œéµå­—ï¼Œ
      // è®“ç¨‹å¼ç¢¼çœ‹èµ·ä¾†åƒåŒæ­¥åŸ·è¡Œï¼Œä½†å¯¦éš›ä¸Šæœƒç­‰å¾…é‹ç®—å®Œæˆã€‚
      // =================================================================
      async function exportToPDF() {
        const button = document.getElementById("exportBtn");
        const originalHTML = button.innerHTML;

        try {
          // é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
          button.innerHTML =
            '<span class="loading"></span><span>ç”Ÿæˆä¸­...</span>';
          button.disabled = true;

          // å–å¾—çµ±è¨ˆæ•¸æ“š
          const stats = calculateStatistics();

          // åˆå§‹åŒ– jsPDF (A4, portrait)
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF("p", "mm", "a4");

          const pageWidth = pdf.internal.pageSize.getWidth();
          const pageHeight = pdf.internal.pageSize.getHeight();
          const margin = 20;
          const contentWidth = pageWidth - margin * 2;

          let yPos = margin;

          // =================================================================
          // ç¬¬ä¸€é ï¼šå°é¢èˆ‡ç¸½è¦½
          // =================================================================

          // æ¨™é¡Œï¼ˆä½¿ç”¨ SVG ç”Ÿæˆä¸­æ–‡åœ–ç‰‡ï¼‰
          try {
            const titleImg = await createChineseTextImage(
              "DCCS èªçŸ¥å½ˆæ€§è¨“ç·´",
              48,
              "bold",
              "#1e3a5f",
            );
            const titleWidth = Math.min(contentWidth, titleImg.width * 0.15);
            const titleHeight = titleImg.height * (titleWidth / titleImg.width);

            pdf.addImage(
              titleImg.dataUrl,
              "PNG",
              (pageWidth - titleWidth) / 2,
              yPos,
              titleWidth,
              titleHeight,
              undefined,
              "FAST",
            );
            yPos += titleHeight + 5;

            const subtitleImg = await createChineseTextImage(
              "è³‡æ–™åˆ†æå ±å‘Š",
              36,
              "normal",
              "#1e3a5f",
            );
            const subtitleWidth = Math.min(
              contentWidth,
              subtitleImg.width * 0.15,
            );
            const subtitleHeight =
              subtitleImg.height * (subtitleWidth / subtitleImg.width);

            pdf.addImage(
              subtitleImg.dataUrl,
              "PNG",
              (pageWidth - subtitleWidth) / 2,
              yPos,
              subtitleWidth,
              subtitleHeight,
              undefined,
              "FAST",
            );
            yPos += subtitleHeight + 15;
          } catch (e) {
            console.error("Title image generation failed:", e);
            // å›é€€åˆ°è‹±æ–‡æ¨™é¡Œ
            pdf.setFontSize(24);
            pdf.setFont("helvetica", "bold");
            pdf.text(
              "DCCS Cognitive Flexibility Training",
              pageWidth / 2,
              yPos,
              { align: "center" },
            );
            yPos += 8;
            pdf.setFontSize(18);
            pdf.text("Data Analysis Report", pageWidth / 2, yPos, {
              align: "center",
            });
            yPos += 15;
          }

          // åˆ†éš”ç·š
          pdf.setDrawColor(30, 58, 95);
          pdf.setLineWidth(0.5);
          pdf.line(margin, yPos, pageWidth - margin, yPos);
          yPos += 12;

          // å—è©¦è€…è³‡è¨Šï¼ˆä¸­æ–‡æ¨™é¡Œ + è‹±æ–‡å…§å®¹ï¼‰
          try {
            const infoTitleImg = await createChineseTextImage(
              "å—è©¦è€…è³‡è¨Š",
              24,
              "bold",
              "#1e3a5f",
            );
            const infoTitleWidth = Math.min(
              contentWidth * 0.4,
              infoTitleImg.width * 0.08,
            );
            const infoTitleHeight =
              infoTitleImg.height * (infoTitleWidth / infoTitleImg.width);

            pdf.addImage(
              infoTitleImg.dataUrl,
              "PNG",
              margin,
              yPos - 3,
              infoTitleWidth,
              infoTitleHeight,
              undefined,
              "FAST",
            );
            yPos += infoTitleHeight + 5;
          } catch (e) {
            pdf.setFontSize(12);
            pdf.setFont("helvetica", "bold");
            pdf.text("Participant Information", margin, yPos);
            yPos += 8;
          }

          pdf.setFont("helvetica", "normal");
          pdf.setFontSize(11);
          const participantId = csvData[0].participant_id || "N/A";
          pdf.text(
            `å—è©¦è€…ç·¨è™Ÿ Participant ID: ${participantId}`,
            margin + 5,
            yPos,
          );
          yPos += 6;
          pdf.text(
            `åˆ†ææ—¥æœŸ Analysis Date: ${new Date().toLocaleDateString("zh-TW")} / ${new Date().toLocaleDateString("en-US")}`,
            margin + 5,
            yPos,
          );
          yPos += 6;
          pdf.text(`è³‡æ–™ç­†æ•¸ Total Trials: ${stats.total}`, margin + 5, yPos);
          yPos += 12;

          // ä½¿ç”¨ autoTable ç¹ªè£½ç¸½è¦½çµ±è¨ˆè¡¨ï¼ˆé›™èªè¡¨é ­ï¼‰
          try {
            const overviewTitleImg = await createChineseTextImage(
              "æ•´é«”è¡¨ç¾ç¸½è¦½",
              24,
              "bold",
              "#1e3a5f",
            );
            const overviewTitleWidth = Math.min(
              contentWidth * 0.4,
              overviewTitleImg.width * 0.08,
            );
            const overviewTitleHeight =
              overviewTitleImg.height *
              (overviewTitleWidth / overviewTitleImg.width);

            pdf.addImage(
              overviewTitleImg.dataUrl,
              "PNG",
              margin,
              yPos - 3,
              overviewTitleWidth,
              overviewTitleHeight,
              undefined,
              "FAST",
            );
            yPos += overviewTitleHeight + 3;
          } catch (e) {
            pdf.setFont("helvetica", "bold");
            pdf.setFontSize(12);
            pdf.text("Overall Performance Summary", margin, yPos);
            yPos += 5;
          }

          pdf.autoTable({
            startY: yPos,
            head: [["æŒ‡æ¨™ Metric", "æ•¸å€¼ Value"]],
            body: [
              ["ç¸½è©¦é¡Œæ•¸ Total Trials", `${stats.total}`],
              ["æ­£ç¢ºé¡Œæ•¸ Correct Trials", `${stats.correct}`],
              ["æ•´é«”æ­£ç¢ºç‡ Overall Accuracy", `${stats.accuracy}%`],
              ["å¹³å‡åæ‡‰æ™‚é–“ Average RT", `${stats.avgRT} ms`],
              ["æœ€å¿«åæ‡‰æ™‚é–“ Min RT", `${stats.minRT} ms`],
              ["æœ€æ…¢åæ‡‰æ™‚é–“ Max RT", `${stats.maxRT} ms`],
            ],
            theme: "grid",
            headStyles: {
              fillColor: [30, 58, 95],
              fontSize: 9,
              fontStyle: "bold",
            },
            bodyStyles: {
              fontSize: 9,
            },
            margin: { left: margin, right: margin },
            tableWidth: contentWidth,
          });

          yPos = pdf.lastAutoTable.finalY + 10;

          // éšæ®µåˆ¥çµ±è¨ˆ
          try {
            const phaseTitleImg = await createChineseTextImage(
              "éšæ®µåˆ¥è©³ç´°çµ±è¨ˆ",
              24,
              "bold",
              "#1e3a5f",
            );
            const phaseTitleWidth = Math.min(
              contentWidth * 0.4,
              phaseTitleImg.width * 0.08,
            );
            const phaseTitleHeight =
              phaseTitleImg.height * (phaseTitleWidth / phaseTitleImg.width);

            pdf.addImage(
              phaseTitleImg.dataUrl,
              "PNG",
              margin,
              yPos - 3,
              phaseTitleWidth,
              phaseTitleHeight,
              undefined,
              "FAST",
            );
            yPos += phaseTitleHeight + 3;
          } catch (e) {
            pdf.setFont("helvetica", "bold");
            pdf.setFontSize(12);
            pdf.text("Performance by Phase", margin, yPos);
            yPos += 5;
          }

          pdf.autoTable({
            startY: yPos,
            head: [
              [
                "éšæ®µ Phase",
                "è©¦é¡Œæ•¸ Trials",
                "æ­£ç¢ºæ•¸ Correct",
                "æ­£ç¢ºç‡ Accuracy",
                "å¹³å‡RT Avg RT(ms)",
              ],
            ],
            body: [
              [
                "éšæ®µä¸€(é¡è‰²) Phase 1(Color)",
                stats.phases[1].total,
                stats.phases[1].correct,
                `${stats.phases[1].accuracy}%`,
                stats.phases[1].avgRT,
              ],
              [
                "éšæ®µäºŒ(å½¢ç‹€) Phase 2(Shape)",
                stats.phases[2].total,
                stats.phases[2].correct,
                `${stats.phases[2].accuracy}%`,
                stats.phases[2].avgRT,
              ],
              [
                "éšæ®µä¸‰(æ··åˆ) Phase 3(Mixed)",
                stats.phases[3].total,
                stats.phases[3].correct,
                `${stats.phases[3].accuracy}%`,
                stats.phases[3].avgRT,
              ],
            ],
            theme: "grid",
            headStyles: {
              fillColor: [30, 58, 95],
              fontSize: 8,
              fontStyle: "bold",
            },
            bodyStyles: {
              fontSize: 8,
            },
            margin: { left: margin, right: margin },
            tableWidth: contentWidth,
          });

          yPos = pdf.lastAutoTable.finalY + 10;

          // è¦å‰‡é¡å‹çµ±è¨ˆ
          try {
            const ruleTitleImg = await createChineseTextImage(
              "è¦å‰‡é¡å‹è¡¨ç¾",
              24,
              "bold",
              "#1e3a5f",
            );
            const ruleTitleWidth = Math.min(
              contentWidth * 0.4,
              ruleTitleImg.width * 0.08,
            );
            const ruleTitleHeight =
              ruleTitleImg.height * (ruleTitleWidth / ruleTitleImg.width);

            pdf.addImage(
              ruleTitleImg.dataUrl,
              "PNG",
              margin,
              yPos - 3,
              ruleTitleWidth,
              ruleTitleHeight,
              undefined,
              "FAST",
            );
            yPos += ruleTitleHeight + 3;
          } catch (e) {
            pdf.setFont("helvetica", "bold");
            pdf.setFontSize(12);
            pdf.text("Performance by Rule Type", margin, yPos);
            yPos += 5;
          }

          pdf.autoTable({
            startY: yPos,
            head: [
              [
                "è¦å‰‡é¡å‹ Rule Type",
                "è©¦é¡Œæ•¸ Trials",
                "æ­£ç¢ºæ•¸ Correct",
                "æ­£ç¢ºç‡ Accuracy",
              ],
            ],
            body: [
              [
                "é¡è‰²è¦å‰‡ Color Rule",
                stats.rules.color.total,
                stats.rules.color.correct,
                `${stats.rules.color.accuracy}%`,
              ],
              [
                "å½¢ç‹€è¦å‰‡ Shape Rule",
                stats.rules.shape.total,
                stats.rules.shape.correct,
                `${stats.rules.shape.accuracy}%`,
              ],
            ],
            theme: "grid",
            headStyles: {
              fillColor: [30, 58, 95],
              fontSize: 9,
              fontStyle: "bold",
            },
            bodyStyles: {
              fontSize: 9,
            },
            margin: { left: margin, right: margin },
            tableWidth: contentWidth,
          });

          // =================================================================
          // ç¬¬äºŒé ï¼šåœ–è¡¨
          // =================================================================
          pdf.addPage();
          yPos = margin;

          try {
            const chartsTitleImg = await createChineseTextImage(
              "è¦–è¦ºåŒ–åˆ†æåœ–è¡¨",
              32,
              "bold",
              "#1e3a5f",
            );
            const chartsTitleWidth = Math.min(
              contentWidth,
              chartsTitleImg.width * 0.1,
            );
            const chartsTitleHeight =
              chartsTitleImg.height * (chartsTitleWidth / chartsTitleImg.width);

            pdf.addImage(
              chartsTitleImg.dataUrl,
              "PNG",
              (pageWidth - chartsTitleWidth) / 2,
              yPos,
              chartsTitleWidth,
              chartsTitleHeight,
              undefined,
              "FAST",
            );
            yPos += chartsTitleHeight + 10;
          } catch (e) {
            pdf.setFontSize(16);
            pdf.setFont("helvetica", "bold");
            pdf.text("Visual Analysis Charts", pageWidth / 2, yPos, {
              align: "center",
            });
            yPos += 15;
          }

          // æ“·å–ä¸¦æ’å…¥åœ–è¡¨
          const charts = [
            {
              id: "accuracyChart",
              title: "éšæ®µåˆ¥æ­£ç¢ºç‡",
              titleEn: "Accuracy by Phase",
            },
            {
              id: "reactionTimeChart",
              title: "åæ‡‰æ™‚é–“è¶¨å‹¢",
              titleEn: "Reaction Time Trend",
            },
          ];

          for (const chartInfo of charts) {
            const canvas = document.getElementById(chartInfo.id);
            if (canvas) {
              try {
                await new Promise((resolve) => setTimeout(resolve, 100));

                // åœ–è¡¨æ¨™é¡Œï¼ˆä¸­è‹±æ–‡ï¼‰
                try {
                  const chartTitleImg = await createChineseTextImage(
                    chartInfo.title,
                    24,
                    "bold",
                    "#1e3a5f",
                  );
                  const chartTitleWidth = Math.min(
                    contentWidth * 0.5,
                    chartTitleImg.width * 0.08,
                  );
                  const chartTitleHeight =
                    chartTitleImg.height *
                    (chartTitleWidth / chartTitleImg.width);

                  pdf.addImage(
                    chartTitleImg.dataUrl,
                    "PNG",
                    margin,
                    yPos - 2,
                    chartTitleWidth,
                    chartTitleHeight,
                    undefined,
                    "FAST",
                  );
                  yPos += chartTitleHeight + 5;
                } catch (e) {
                  pdf.setFontSize(12);
                  pdf.setFont("helvetica", "bold");
                  pdf.text(chartInfo.titleEn, margin, yPos);
                  yPos += 8;
                }

                const imgData = canvas.toDataURL("image/png", 1.0);
                const imgWidth = contentWidth;
                const imgHeight = (canvas.height / canvas.width) * imgWidth;

                if (yPos + imgHeight > pageHeight - margin) {
                  pdf.addPage();
                  yPos = margin;
                }

                pdf.addImage(
                  imgData,
                  "PNG",
                  margin,
                  yPos,
                  imgWidth,
                  imgHeight,
                  undefined,
                  "FAST",
                );
                yPos += imgHeight + 15;
              } catch (e) {
                console.error(`Chart ${chartInfo.id} capture failed:`, e);
              }
            }
          }

          // =================================================================
          // ç¬¬ä¸‰é ï¼šæ›´å¤šåœ–è¡¨
          // =================================================================
          pdf.addPage();
          yPos = margin;

          const moreCharts = [
            {
              id: "ruleTypeChart",
              title: "è¦å‰‡é¡å‹è¡¨ç¾åˆ†å¸ƒ",
              titleEn: "Rule Type Distribution",
            },
            {
              id: "errorDistChart",
              title: "éŒ¯èª¤åˆ†å¸ƒ",
              titleEn: "Error Distribution",
            },
          ];

          for (const chartInfo of moreCharts) {
            const canvas = document.getElementById(chartInfo.id);
            if (canvas) {
              try {
                await new Promise((resolve) => setTimeout(resolve, 100));

                // åœ–è¡¨æ¨™é¡Œï¼ˆä¸­è‹±æ–‡ï¼‰
                try {
                  const chartTitleImg = await createChineseTextImage(
                    chartInfo.title,
                    24,
                    "bold",
                    "#1e3a5f",
                  );
                  const chartTitleWidth = Math.min(
                    contentWidth * 0.5,
                    chartTitleImg.width * 0.08,
                  );
                  const chartTitleHeight =
                    chartTitleImg.height *
                    (chartTitleWidth / chartTitleImg.width);

                  pdf.addImage(
                    chartTitleImg.dataUrl,
                    "PNG",
                    margin,
                    yPos - 2,
                    chartTitleWidth,
                    chartTitleHeight,
                    undefined,
                    "FAST",
                  );
                  yPos += chartTitleHeight + 5;
                } catch (e) {
                  pdf.setFontSize(12);
                  pdf.setFont("helvetica", "bold");
                  pdf.text(chartInfo.titleEn, margin, yPos);
                  yPos += 8;
                }

                const imgData = canvas.toDataURL("image/png", 1.0);
                const imgWidth = contentWidth;
                const imgHeight = (canvas.height / canvas.width) * imgWidth;

                if (yPos + imgHeight > pageHeight - margin) {
                  pdf.addPage();
                  yPos = margin;
                }

                pdf.addImage(
                  imgData,
                  "PNG",
                  margin,
                  yPos,
                  imgWidth,
                  imgHeight,
                  undefined,
                  "FAST",
                );
                yPos += imgHeight + 15;
              } catch (e) {
                console.error(`Chart ${chartInfo.id} capture failed:`, e);
              }
            }
          }

          // =================================================================
          // é å°¾è³‡è¨Šï¼ˆæ‰€æœ‰é é¢ï¼‰
          // =================================================================
          const totalPages = pdf.internal.getNumberOfPages();
          for (let i = 1; i <= totalPages; i++) {
            pdf.setPage(i);
            pdf.setFontSize(8);
            pdf.setFont("helvetica", "normal");
            pdf.setTextColor(150);
            pdf.text(
              `ç¬¬ ${i} é ï¼Œå…± ${totalPages} é  | Page ${i} of ${totalPages}`,
              pageWidth / 2,
              pageHeight - 10,
              { align: "center" },
            );
            pdf.text(
              "Â© 2026 ä¸­åŸå¤§å­¸ç‰¹æ®Šæ•™è‚²å­¸ç³» | CYCU Special Education | DCCS èªçŸ¥å½ˆæ€§è¨“ç·´",
              pageWidth / 2,
              pageHeight - 6,
              { align: "center" },
            );
          }

          // ç”Ÿæˆæª”å
          const timestamp = new Date()
            .toISOString()
            .slice(0, 19)
            .replace(/:/g, "-");
          const filename = `DCCSåˆ†æå ±å‘Š_${participantId}_${timestamp}.pdf`;

          // å„²å­˜ PDF
          pdf.save(filename);

          // æˆåŠŸæç¤º
          button.innerHTML = "<span>âœ…</span><span>ä¸‹è¼‰æˆåŠŸï¼</span>";
          setTimeout(() => {
            button.innerHTML = originalHTML;
            button.disabled = false;
          }, 2000);
        } catch (error) {
          console.error("PDF Generation Error:", error);
          alert(
            "PDF ç”Ÿæˆå¤±æ•—ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ§åˆ¶å°ä»¥ç²å–è©³ç´°è³‡è¨Šã€‚\nPDF generation failed. Please check console for details.",
          );
          button.innerHTML = originalHTML;
          button.disabled = false;
        }
      }

      // ç§»é™¤åŸæœ‰çš„ drawTable å‡½æ•¸ï¼Œå› ç‚ºå·²æ”¹ç”¨ autoTable
    </script>
  </body>
</html>
